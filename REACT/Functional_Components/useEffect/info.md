Зачем использовать useEffect?
До хуков функциональные компоненты использовались только для приема данных в форме реквизитов и возврата некоторого JSX для рендеринга. Однако, как мы узнали на последнем уроке, State Hook позволяет нам управлять динамическими данными в форме состояния компонентов внутри наших функциональных компонентов.

В этом уроке мы будем использовать обработчик эффектов для запуска некоторого кода JavaScript после каждого рендеринга, например:

получение данных из серверной службы
подписка на поток данных
управление таймерами и интервалами
чтение и внесение изменений в DOM
Почему после каждого рендера?
Наиболее интересные компоненты будут повторно визуализироваться несколько раз в течение своего жизненного цикла, и эти ключевые моменты предоставляют прекрасную возможность реализовать эти «побочные эффекты».

Есть три ключевых момента, когда можно использовать Effect Hook:

Когда компонент впервые добавляется или монтируется в DOM и отрисовывается
Когда состояние или свойства меняются, вызывая повторный рендеринг компонента
Когда компонент удален или размонтирован из DOM.
Позже в этом уроке мы узнаем, как в дальнейшем точно настроить время выполнения этого кода.

инструкции
В редакторе мы определили компонент как класс и функцию, каждая из которых имеет одинаковые «побочные эффекты».

Даже если вы не знакомы с методами жизненного цикла компонентов класса , начните с рассмотрения обеих реализаций, чтобы получить представление об обоих вариантах.

Примечание. Понимание методов жизненного цикла в компонентах класса не является обязательным условием для этого урока.

В компоненте класса в PageTitleClass.js логика установки заголовка документа разделена между двумя функциями - componentDidMount()и componentDidUpdate().

Сравните это с функциональным компонентом в PageTitleFunction.js , где логика написана в одном месте - useEffect().

Обе реализации компонентов имеют одинаковое поведение, но читать и поддерживать функциональный компонент будет проще.

Готовы начать использовать Effect Hook? Большой! Мы подробно рассмотрим, как использовать этот крючок на этом уроке!

============================================================================

Эффекты функционального компонента
Давайте разберемся, как наш PageTitle()функциональный компонент использует обработчик эффектов для выполнения кода после каждого рендеринга!

import React, { useState, useEffect } from 'react';
 
function PageTitle() {
  const [name, setName] = useState('');
 
  useEffect(() => {
    document.title = `Hi, ${name}`;
  });
 
  return (
    <div>
      <p>Use the input field below to rename this page!</p>
      <input onChange={({target}) => setName(target.value)} value={name} type='text' />
    </div>
  );
}
Сначала мы импортируем обработчик эффекта из reactбиблиотеки, например:

import { useEffect } from 'react';
Обработчик эффекта используется для вызова другой функции, которая что-то делает за нас, поэтому при вызове useEffect()функции ничего не возвращается .

Первым аргументом, переданным useEffect()функции, является функция обратного вызова, которую мы хотим, чтобы React вызывал после каждого рендеринга этого компонента. Мы будем называть эту функцию обратного вызова нашим эффектом .

В нашем примере эффект следующий:

() => { document.title = name; }
В нашем случае мы присваиваем значение nameпеременной document.title. Чтобы узнать больше об этом синтаксисе, ознакомьтесь с этим объяснением свойства title документа .

Обратите внимание, как мы используем текущее состояние внутри нашего эффекта. Несмотря на то, что наш эффект вызывается после рендеринга компонента, у нас все еще есть доступ к переменным в области видимости нашего функционального компонента! Когда React отображает наш компонент, он обновляет DOM как обычно, а затем запускает наш эффект после обновления DOM. Это происходит для каждого рендера, включая первый и последний.

===============================================================

Эффекты очистки
Некоторые эффекты требуют очистки. Например, мы могли бы захотеть добавить слушателей событий к какому-либо элементу в DOM, помимо JSX в нашем компоненте. Когда мы добавляем прослушиватели событий в DOM , важно удалить эти прослушиватели событий, когда мы закончим с ними, чтобы избежать утечек памяти !

Рассмотрим следующий эффект:

useEffect(()=>{
  document.addEventListener('keydown', handleKeyPress);
  return () => {
    document.removeEventListener('keydown', handleKeyPress);
  };
})
Если наш эффект не вернул функцию очистки , то новый прослушиватель событий будет добавляться к documentобъекту DOM каждый раз, когда наш компонент повторно отрисовывает. Это не только вызовет ошибки, но и может привести к снижению производительности нашего приложения и, возможно, даже к сбою!

Поскольку эффекты запускаются после каждого рендеринга, а не только один раз, React вызывает нашу функцию очистки перед каждым повторным рендерингом и перед размонтированием, чтобы очистить каждый вызов эффекта.

Если наш эффект возвращает функцию, то useEffect()ловушка всегда рассматривает это как функцию очистки. React вызовет эту функцию очистки перед повторным рендерингом или отключением компонента. Поскольку эта функция очистки является необязательной, мы обязаны вернуть функцию очистки из нашего эффекта, когда наш код эффекта может вызвать утечку памяти.

==========================================================================
