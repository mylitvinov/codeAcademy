Зачем использовать useEffect?
До хуков функциональные компоненты использовались только для приема данных в форме реквизитов и возврата некоторого JSX для рендеринга. Однако, как мы узнали на последнем уроке, State Hook позволяет нам управлять динамическими данными в форме состояния компонентов внутри наших функциональных компонентов.

В этом уроке мы будем использовать обработчик эффектов для запуска некоторого кода JavaScript после каждого рендеринга, например:

получение данных из серверной службы
подписка на поток данных
управление таймерами и интервалами
чтение и внесение изменений в DOM
Почему после каждого рендера?
Наиболее интересные компоненты будут повторно визуализироваться несколько раз в течение своего жизненного цикла, и эти ключевые моменты предоставляют прекрасную возможность реализовать эти «побочные эффекты».

Есть три ключевых момента, когда можно использовать Effect Hook:

Когда компонент впервые добавляется или монтируется в DOM и отрисовывается
Когда состояние или свойства меняются, вызывая повторный рендеринг компонента
Когда компонент удален или размонтирован из DOM.
Позже в этом уроке мы узнаем, как в дальнейшем точно настроить время выполнения этого кода.

инструкции
В редакторе мы определили компонент как класс и функцию, каждая из которых имеет одинаковые «побочные эффекты».

Даже если вы не знакомы с методами жизненного цикла компонентов класса , начните с рассмотрения обеих реализаций, чтобы получить представление об обоих вариантах.

Примечание. Понимание методов жизненного цикла в компонентах класса не является обязательным условием для этого урока.

В компоненте класса в PageTitleClass.js логика установки заголовка документа разделена между двумя функциями - componentDidMount()и componentDidUpdate().

Сравните это с функциональным компонентом в PageTitleFunction.js , где логика написана в одном месте - useEffect().

Обе реализации компонентов имеют одинаковое поведение, но читать и поддерживать функциональный компонент будет проще.

Готовы начать использовать Effect Hook? Большой! Мы подробно рассмотрим, как использовать этот крючок на этом уроке!

============================================================================

Эффекты функционального компонента
Давайте разберемся, как наш PageTitle()функциональный компонент использует обработчик эффектов для выполнения кода после каждого рендеринга!

import React, { useState, useEffect } from 'react';
 
function PageTitle() {
  const [name, setName] = useState('');
 
  useEffect(() => {
    document.title = `Hi, ${name}`;
  });
 
  return (
    <div>
      <p>Use the input field below to rename this page!</p>
      <input onChange={({target}) => setName(target.value)} value={name} type='text' />
    </div>
  );
}
Сначала мы импортируем обработчик эффекта из reactбиблиотеки, например:

import { useEffect } from 'react';
Обработчик эффекта используется для вызова другой функции, которая что-то делает за нас, поэтому при вызове useEffect()функции ничего не возвращается .

Первым аргументом, переданным useEffect()функции, является функция обратного вызова, которую мы хотим, чтобы React вызывал после каждого рендеринга этого компонента. Мы будем называть эту функцию обратного вызова нашим эффектом .

В нашем примере эффект следующий:

() => { document.title = name; }
В нашем случае мы присваиваем значение nameпеременной document.title. Чтобы узнать больше об этом синтаксисе, ознакомьтесь с этим объяснением свойства title документа .

Обратите внимание, как мы используем текущее состояние внутри нашего эффекта. Несмотря на то, что наш эффект вызывается после рендеринга компонента, у нас все еще есть доступ к переменным в области видимости нашего функционального компонента! Когда React отображает наш компонент, он обновляет DOM как обычно, а затем запускает наш эффект после обновления DOM. Это происходит для каждого рендера, включая первый и последний.

===============================================================

Эффекты очистки
Некоторые эффекты требуют очистки. Например, мы могли бы захотеть добавить слушателей событий к какому-либо элементу в DOM, помимо JSX в нашем компоненте. Когда мы добавляем прослушиватели событий в DOM , важно удалить эти прослушиватели событий, когда мы закончим с ними, чтобы избежать утечек памяти !

Рассмотрим следующий эффект:

useEffect(()=>{
  document.addEventListener('keydown', handleKeyPress);
  return () => {
    document.removeEventListener('keydown', handleKeyPress);
  };
})
Если наш эффект не вернул функцию очистки , то новый прослушиватель событий будет добавляться к documentобъекту DOM каждый раз, когда наш компонент повторно отрисовывает. Это не только вызовет ошибки, но и может привести к снижению производительности нашего приложения и, возможно, даже к сбою!

Поскольку эффекты запускаются после каждого рендеринга, а не только один раз, React вызывает нашу функцию очистки перед каждым повторным рендерингом и перед размонтированием, чтобы очистить каждый вызов эффекта.

Если наш эффект возвращает функцию, то useEffect()ловушка всегда рассматривает это как функцию очистки. React вызовет эту функцию очистки перед повторным рендерингом или отключением компонента. Поскольку эта функция очистки является необязательной, мы обязаны вернуть функцию очистки из нашего эффекта, когда наш код эффекта может вызвать утечку памяти.

==========================================================================

Управление вызовом эффектов
useEffect()Функция вызывает свой первый аргумент (эффект) после того, как каждый раз , когда компонент делает. Мы узнали, как вернуть функцию очистки, чтобы не создавать проблем с производительностью и других ошибок, но иногда мы хотим вообще пропустить вызов нашего эффекта при повторном рендеринге.

Обычно при определении функциональных компонентов эффект запускается только при монтировании компонента (рендеринге в первый раз), но не при повторном рендеринге компонента. С помощью Effect Hook нам это очень легко сделать! Если мы хотим вызвать наш эффект только после первого рендеринга, мы передаем пустой массив в useEffect()качестве второго аргумента. Этот второй аргумент называется массивом зависимостей .

Массив зависимостей используется для указания useEffect()методу, когда вызывать наш эффект, а когда его пропускать. Наш эффект всегда вызывается после первого рендеринга, но вызывается снова только в том случае, если что-то в нашем массиве зависимостей изменило значения между рендерами.

Мы продолжим изучать этот второй аргумент в следующих нескольких упражнениях, но пока мы сосредоточимся на использовании пустого массива зависимостей для вызова эффекта при первом монтировании компонента, и если функция очистки возвращается нашим эффектом , вызывая это при размонтировании компонента.

useEffect(() => {
  alert("component rendered for the first time");
  return () => {
    alert("component is being removed from the DOM");
  };
}, []); 
Без передачи пустого массива в качестве второго аргумента useEffect()вышеупомянутого, эти предупреждения будут отображаться до и после каждого рендеринга нашего компонента, что явно не в том случае, когда эти сообщения должны отображаться. Просто перехода []к useEffect()функции достаточно, чтобы настроить, когда вызываются функции эффекта и очистки!

=========================================================================

Получить данные
При создании программного обеспечения мы часто начинаем с поведения по умолчанию, а затем изменяем его для повышения производительности. Мы узнали, что по умолчанию обработчик эффектов вызывает функцию эффекта после каждого рендеринга. Затем мы узнали, что можем передать пустой массив в качестве второго аргумента, useEffect()если мы хотим, чтобы наш эффект вызывался только после первого рендеринга компонента. В этом упражнении мы научимся использовать массив зависимостей для дальнейшей настройки именно тогда, когда мы хотим, чтобы наш эффект был вызван!

Когда наш эффект отвечает за выборку данных с сервера, мы уделяем особое внимание тому, когда вызывается наш эффект. Ненужные обходы между нашими компонентами React и сервером могут быть дорогостоящими с точки зрения:

Обработка
Представление
Использование данных для мобильных пользователей
Плата за услуги API
Когда данные, которые наши компоненты должны визуализировать, не меняются, мы можем передать пустой массив зависимостей, чтобы данные были извлечены после первого рендеринга. Когда ответ получен от сервера, мы можем использовать установщик состояния из State Hook, чтобы сохранить данные из ответа сервера в нашем локальном состоянии компонента для будущих рендеров. Совместное использование State Hook и Effect Hook таким образом является мощным паттерном, который избавляет наши компоненты от ненужного извлечения новых данных после каждого рендеринга!

Пустой массив зависимостей сигнализирует ловушке эффекта, что наш эффект никогда не нужно запускать повторно, что он ни от чего не зависит. Указание нулевых зависимостей означает, что результат запуска этого эффекта не изменится, и достаточно вызвать наш эффект один раз.

Массив зависимостей, который не является пустым, сигнализирует обработчику эффекта, что он может пропустить вызов нашего эффекта после повторного рендеринга, если только значение одной из переменных в нашем массиве зависимостей не изменилось. Если значение зависимости изменилось, обработчик эффекта снова вызовет наш эффект!

Вот хороший пример из официальных документов React :

useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // Only re-run the effect if the value stored by count changes

=====================================================================

Правила крючков
При использовании хуков следует помнить о двух основных правилах:

вызовите хуки только на верхнем уровне
вызывать хуки только из функций React
Поскольку мы практиковались с State Hook и Effect Hook, мы с легкостью следовали этим правилам, но полезно помнить об этих двух правилах, когда вы выносите свое новое понимание хуков и начинаете использовать больше хуков в ваших приложениях React.

Когда React строит виртуальную модель DOM, библиотека снова и снова вызывает функции, которые определяют наши компоненты, когда пользователь взаимодействует с пользовательским интерфейсом. React отслеживает данные и функции, которыми мы управляем с помощью хуков, в зависимости от их порядка в определении функционального компонента. По этой причине мы всегда называем наши хуки на верхнем уровне; мы никогда не вызываем ловушки внутри циклов, условий или вложенных функций.

Вместо того, чтобы путать React с таким кодом:

if (userName !== '') {
  useEffect(() => {
    localStorage.setItem('savedUserName', userName);
  });
}
Мы можем достичь той же цели, постоянно вызывая наш Hook каждый раз:

useEffect(() => {
  if (userName !== '') {
    localStorage.setItem('savedUserName', userName);
  }
});
Во-вторых, хуки можно использовать только в функциях React. Мы не можем использовать хуки в компонентах класса, и мы не можем использовать хуки в обычных функциях JavaScript. Мы работаем с useState()и useEffect()компонентами функции, и это наиболее распространенное использование. Единственное другое место, где можно использовать хуки, - это кастомные хуки. Пользовательские хуки невероятно полезны для организации и повторного использования логики с отслеживанием состояния между функциональными компонентами. Для получения дополнительной информации по этой теме перейдите в React Docs .
=============================================================================

Отдельные крючки для отдельных эффектов
Когда несколько значений тесно связаны и изменяются одновременно, имеет смысл сгруппировать эти значения в коллекцию, такую ​​как объект или массив. Объединение данных вместе может также усложнить код, отвечающий за управление этими данными. Поэтому рекомендуется разделять проблемы, управляя разными данными с помощью разных хуков.

Сравните сложность здесь, когда данные объединены в один объект:

// Handle both position and menuItems with one useEffect hook.
const [data, setData] = useState({ position: { x: 0, y: 0 } });
useEffect(() => {
  get('/menu').then((response) => {
    setData((prev) => ({ ...prev, menuItems: response.data }));
  });
  const handleMove = (event) =>
    setData((prev) => ({
      ...prev,
      position: { x: event.clientX, y: event.clientY }
    }));
  window.addEventListener('mousemove', handleMove);
  return () => window.removeEventListener('mousemove', handleMove);
}, []);
Для простоты здесь мы разделили проблемы:

// Handle menuItems with one useEffect hook.
const [menuItems, setMenuItems] = useState(null);
useEffect(() => {
  get('/menu').then((response) => setMenuItems(response.data));
}, []);
 
// Handle position with a separate useEffect hook.
const [position, setPosition] = useState({ x: 0, y: 0 });
useEffect(() => {
  const handleMove = (event) =>
    setPosition({ x: event.clientX, y: event.clientY });
  window.addEventListener('mousemove', handleMove);
  return () => window.removeEventListener('mousemove', handleMove);
}, []);
Не всегда очевидно , объединять ли данные вместе или разделять их , но с практикой мы научимся лучше организовывать наш код, чтобы его было легче понять, добавить, повторно использовать и протестировать!
