Зачем использовать useEffect?
До хуков функциональные компоненты использовались только для приема данных в форме реквизитов и возврата некоторого JSX для рендеринга. Однако, как мы узнали на последнем уроке, State Hook позволяет нам управлять динамическими данными в форме состояния компонентов внутри наших функциональных компонентов.

В этом уроке мы будем использовать обработчик эффектов для запуска некоторого кода JavaScript после каждого рендеринга, например:

получение данных из серверной службы
подписка на поток данных
управление таймерами и интервалами
чтение и внесение изменений в DOM
Почему после каждого рендера?
Наиболее интересные компоненты будут повторно визуализироваться несколько раз в течение своего жизненного цикла, и эти ключевые моменты предоставляют прекрасную возможность реализовать эти «побочные эффекты».

Есть три ключевых момента, когда можно использовать Effect Hook:

Когда компонент впервые добавляется или монтируется в DOM и отрисовывается
Когда состояние или свойства меняются, вызывая повторный рендеринг компонента
Когда компонент удален или размонтирован из DOM.
Позже в этом уроке мы узнаем, как в дальнейшем точно настроить время выполнения этого кода.

инструкции
В редакторе мы определили компонент как класс и функцию, каждая из которых имеет одинаковые «побочные эффекты».

Даже если вы не знакомы с методами жизненного цикла компонентов класса , начните с рассмотрения обеих реализаций, чтобы получить представление об обоих вариантах.

Примечание. Понимание методов жизненного цикла в компонентах класса не является обязательным условием для этого урока.

В компоненте класса в PageTitleClass.js логика установки заголовка документа разделена между двумя функциями - componentDidMount()и componentDidUpdate().

Сравните это с функциональным компонентом в PageTitleFunction.js , где логика написана в одном месте - useEffect().

Обе реализации компонентов имеют одинаковое поведение, но читать и поддерживать функциональный компонент будет проще.

Готовы начать использовать Effect Hook? Большой! Мы подробно рассмотрим, как использовать этот крючок на этом уроке!

============================================================================

Эффекты функционального компонента
Давайте разберемся, как наш PageTitle()функциональный компонент использует обработчик эффектов для выполнения кода после каждого рендеринга!

import React, { useState, useEffect } from 'react';
 
function PageTitle() {
  const [name, setName] = useState('');
 
  useEffect(() => {
    document.title = `Hi, ${name}`;
  });
 
  return (
    <div>
      <p>Use the input field below to rename this page!</p>
      <input onChange={({target}) => setName(target.value)} value={name} type='text' />
    </div>
  );
}
Сначала мы импортируем обработчик эффекта из reactбиблиотеки, например:

import { useEffect } from 'react';
Обработчик эффекта используется для вызова другой функции, которая что-то делает за нас, поэтому при вызове useEffect()функции ничего не возвращается .

Первым аргументом, переданным useEffect()функции, является функция обратного вызова, которую мы хотим, чтобы React вызывал после каждого рендеринга этого компонента. Мы будем называть эту функцию обратного вызова нашим эффектом .

В нашем примере эффект следующий:

() => { document.title = name; }
В нашем случае мы присваиваем значение nameпеременной document.title. Чтобы узнать больше об этом синтаксисе, ознакомьтесь с этим объяснением свойства title документа .

Обратите внимание, как мы используем текущее состояние внутри нашего эффекта. Несмотря на то, что наш эффект вызывается после рендеринга компонента, у нас все еще есть доступ к переменным в области видимости нашего функционального компонента! Когда React отображает наш компонент, он обновляет DOM как обычно, а затем запускает наш эффект после обновления DOM. Это происходит для каждого рендера, включая первый и последний.