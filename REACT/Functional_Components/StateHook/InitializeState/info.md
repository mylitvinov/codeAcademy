Состояние инициализации
Отличная работа по созданию вашего первого функционального компонента с отслеживанием состояния в последнем упражнении. Так же, как вы использовали State Hook для управления переменной со строковыми значениями, мы можем использовать State Hook для управления значением любого примитивного типа данных и даже коллекций данных, таких как массивы и объекты!

Взгляните на следующий функциональный компонент. Какой тип данных содержит эта переменная состояния?

import React, { useState } from 'react';
 
function ToggleLoading() {
  const [isLoading, setIsLoading] = useState();
 
  return (
    <div>
      <p>The data is {isLoading ? 'Loading' : 'Not Loading'}</p>
      <button onClick={() => setIsLoading(true)}>
        Turn Loading On
      </button>
      <button onClick={() => setIsLoading(false)}>
        Turn Loading Off
      </button>
    </div>
  );
}
Компонент ToggleLoading()функции выше использует простейший из всех типов данных, логическое значение. Логические значения часто используются в приложениях React для обозначения того, загружены ли данные или нет. В приведенном выше примере мы видим, что trueи falseзначения передаются установщику состояния setIsLoading(). Этот код работает нормально, но что, если мы хотим, чтобы наш компонент запускался с isLoadingустановленным значением true?

Чтобы инициализировать наше состояние любым значением, которое мы хотим, мы просто передаем начальное значение в качестве аргумента при useState() вызове функции.

const [isLoading, setIsLoading] = useState(true);
Этот код влияет на наш компонент тремя способами:

Во время первого рендеринга используется аргумент начального состояния .
Когда вызывается установщик состояния, React игнорирует аргумент начального состояния и использует новое значение.
Когда компонент повторно отрисовывается по любой другой причине, React продолжает использовать то же значение, что и при предыдущем отрисовке.
Если мы не передаем начальное значение при вызове useState(), то текущее значение состояния во время первого рендеринга будет undefined. Часто это совершенно нормально для машин, но может быть непонятно людям, читающим наш код. Итак, мы предпочитаем явно инициализировать наше состояние. Если у нас нет значения, необходимого во время первого рендеринга, мы можем явно передать, nullа не просто пассивно оставить значение как undefined.

=======================================================================================

