Проще говоря, React Hooks - это функции, которые позволяют нам управлять внутренним состоянием компонентов и обрабатывать побочные эффекты пост-рендеринга непосредственно из наших функциональных компонентов. Хуки не работают внутри классов - они позволяют нам использовать причудливые функции React без классов. Имейте в виду, что функциональные компоненты и React Hooks не заменяют компоненты класса. Они не являются обязательными; просто новый инструмент, которым мы можем воспользоваться.

===================================================================

Примечание. Если вы знакомы с методами жизненного цикла компонентов класса, можно сказать, что хуки позволяют нам «подключаться» к функциям состояния и жизненного цикла непосредственно из наших функциональных компонентов.

React предлагает ряд встроенных хуков. Некоторые из них включают в себя useState(), useEffect(), useContext(), useReducer(), и useRef(). Смотрите полный список в документации .

==========================================================================

Установить из предыдущего состояния
Часто следующее значение нашего состояния вычисляется с использованием текущего состояния. В этом случае лучше всего обновлять состояние с помощью функции обратного вызова. В противном случае мы рискуем зафиксировать устаревшие или «устаревшие» государственные ценности.

Давайте посмотрим на следующий код:

import React, { useState } from 'react';
 
export default function Counter() {
  const [count, setCount] = useState(0);
 
  const increment = () => setCount(prevCount => prevCount + 1);
 
  return (
    <div>
      <p>Wow, you've clicked that button: {count} times</p>
      <button onClick={increment}>Click here!</button>
    </div>
  );
}
При нажатии кнопки вызывается increment()обработчик события. Внутри этой функции мы используем наш setCount()установщик состояния по-новому! Поскольку следующее значение countзависит от предыдущего значения count, мы передаем функцию обратного вызова в качестве аргумента setCount()вместо значения (как мы делали в предыдущих упражнениях).

setCount(prevCount => prevCount + 1)
Когда наш установщик состояния вызывает функцию обратного вызова, эта функция обратного вызова установщика состояния принимает countв качестве аргумента наш предыдущий . Значение, возвращаемое этой функцией обратного вызова установщика состояния, используется как следующее значение count(в данном случае prevCount + 1). Примечание. Мы можем просто позвонить, setCount(count +1)и в этом примере все будет работать так же ... но по причинам, выходящим за рамки этого урока, безопаснее использовать метод обратного вызова. Если вы хотите узнать больше о том, почему метод обратного вызова безопаснее, этот раздел документации - отличное место для начала.

=========================================================================

