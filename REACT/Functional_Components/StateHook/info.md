Проще говоря, React Hooks - это функции, которые позволяют нам управлять внутренним состоянием компонентов и обрабатывать побочные эффекты пост-рендеринга непосредственно из наших функциональных компонентов. Хуки не работают внутри классов - они позволяют нам использовать причудливые функции React без классов. Имейте в виду, что функциональные компоненты и React Hooks не заменяют компоненты класса. Они не являются обязательными; просто новый инструмент, которым мы можем воспользоваться.

===================================================================

Примечание. Если вы знакомы с методами жизненного цикла компонентов класса, можно сказать, что хуки позволяют нам «подключаться» к функциям состояния и жизненного цикла непосредственно из наших функциональных компонентов.

React предлагает ряд встроенных хуков. Некоторые из них включают в себя useState(), useEffect(), useContext(), useReducer(), и useRef(). Смотрите полный список в документации .

==========================================================================

Установить из предыдущего состояния
Часто следующее значение нашего состояния вычисляется с использованием текущего состояния. В этом случае лучше всего обновлять состояние с помощью функции обратного вызова. В противном случае мы рискуем зафиксировать устаревшие или «устаревшие» государственные ценности.

Давайте посмотрим на следующий код:

import React, { useState } from 'react';
 
export default function Counter() {
  const [count, setCount] = useState(0);
 
  const increment = () => setCount(prevCount => prevCount + 1);
 
  return (
    <div>
      <p>Wow, you've clicked that button: {count} times</p>
      <button onClick={increment}>Click here!</button>
    </div>
  );
}
При нажатии кнопки вызывается increment()обработчик события. Внутри этой функции мы используем наш setCount()установщик состояния по-новому! Поскольку следующее значение countзависит от предыдущего значения count, мы передаем функцию обратного вызова в качестве аргумента setCount()вместо значения (как мы делали в предыдущих упражнениях).

setCount(prevCount => prevCount + 1)
Когда наш установщик состояния вызывает функцию обратного вызова, эта функция обратного вызова установщика состояния принимает countв качестве аргумента наш предыдущий . Значение, возвращаемое этой функцией обратного вызова установщика состояния, используется как следующее значение count(в данном случае prevCount + 1). Примечание. Мы можем просто позвонить, setCount(count +1)и в этом примере все будет работать так же ... но по причинам, выходящим за рамки этого урока, безопаснее использовать метод обратного вызова. Если вы хотите узнать больше о том, почему метод обратного вызова безопаснее, этот раздел документации - отличное место для начала.

=========================================================================

Массивы в состоянии
Вспомните, когда вы в последний раз заказывали пиццу через Интернет. Ммммм…

Часть волшебного веб-сайта, который предлагала вам вкусную еду, была построена с помощью такого кода:

import React, { useState } from "react";
 
const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];
 
export default function PersonalPizza() {
  const [selected, setSelected] = useState([]);
 
  const toggleTopping = ({target}) => {
    const clickedTopping = target.value;
    setSelected((prev) => {
     // check if clicked topping is already selected
      if (prev.includes(clickedTopping)) {
        // filter the clicked topping out of state
        return prev.filter(t => t !== clickedTopping);
      } else {
        // add the clicked topping to our state
        return [clickedTopping, ...prev];
      }
    });
  };
 
  return (
    <div>
      {options.map(option => (
        <button value={option} onClick={toggleTopping} key={option}>
          {selected.includes(option) ? "Remove " : "Add "}
          {option}
        </button>
      ))}
      <p>Order a {selected.join(", ")} pizza</p>
    </div>
  );
}
Массивы JavaScript - лучшая модель данных для управления списками JSX и их рендеринга. В этом примере мы используем два массива:

options представляет собой массив, содержащий названия всех доступных начинок для пиццы.
selected представляет собой массив, представляющий выбранные начинки для нашей личной пиццы
optionsМассив содержит статические данные , а это означает , что она не изменится. Нам нравится определять статические модели данных вне наших функциональных компонентов, поскольку их не нужно воссоздавать каждый раз при повторной визуализации нашего компонента. В нашем JSX мы используем этот mapметод для рендеринга кнопки для каждой начинки в нашем optionsмассиве.

selectedМассив содержит динамические данные , а это означает , что она меняется, как правило , основаны на действиях пользователя. Мы инициализируем selectedкак пустой массив. При нажатии кнопки вызывается toggleToppingобработчик события. Обратите внимание, как этот обработчик событий использует информацию из объекта события, чтобы определить, какой слой был нажат.

При обновлении массива в состоянии мы не просто добавляем новые данные в предыдущий массив. Мы заменяем предыдущий массив новым массивом. Это означает, что любую информацию, которую мы хотим сохранить из предыдущего массива, необходимо явно скопировать в наш новый массив. Именно это распространение синтаксис делает для нас: ...prev.

Обратите внимание , как мы используем includes(), filter()и map()методы наших массивов. Если это новость для вас или вы просто хотите освежить в памяти информацию, уделите минуту и ​​ознакомьтесь с этими методами работы с массивами . Нам не нужно быть полноценными гуру JavaScript, чтобы создавать пользовательские интерфейсы React, но мы знаем, что инвестирование времени в укрепление наших навыков JavaScript всегда поможет нам делать больше быстрее (и получать от этого гораздо больше удовольствия) как разработчикам React.

=============================================================================

