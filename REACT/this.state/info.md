Установка начального состояния
Компонент React может получить доступ к динамической информации двумя способами: propsи state.

В отличие props, а компонента stateявляется не передается извне. Компонент сам решает state.

Чтобы компонент имел свойство, stateприсвойте ему stateсвойство. Это свойство следует объявить внутри метода конструктора, например:

class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = { mood: 'decent' };
  }
 
  render() {
    return <div></div>;
  }
}
 
<Example />
Ого, метод конструктора? super(props)? Что тут происходит? Давайте более внимательно посмотрим на этот потенциально незнакомый код:

constructor(props) {
  super(props);
  this.state = { mood: 'decent' };
}
this.stateдолжен быть равен объекту, как в примере выше. Этот объект представляет начальное «состояние» любого экземпляра компонента. Мы объясним это позже!

Как насчет остальной части кода? constructorи superобе являются особенностями ES6, а не только React. Здесь нет ничего особенно React-ы об их использовании. Полное объяснение их функциональность выходит за рамки данного курса, но мы рекомендуем приобщение себя . Важно отметить, что компоненты React всегда должны вызывать superсвои конструкторы для правильной настройки.

Посмотрите на нижнюю часть самого высокого примера кода в этом столбце. <Example />имеет a state, а его stateравно { mood: 'decent' }.

=====================================================================

Доступ к состоянию компонента
Чтобы прочитать компонент state, используйте выражение this.state.name-of-property:

class TodayImFeeling extends React.Component {
  constructor(props) {
    super(props);
    this.state = { mood: 'decent' };
  }
 
  render() {
    return (
      <h1>
        I'm feeling {this.state.mood}!
      </h1>
    );
  }
}
Вышеупомянутый класс компонентов считывает свойство stateизнутри своей renderфункции.

Точно так же this.propsвы можете использовать this.stateлюбое свойство, определенное внутри тела класса компонента.

=====================================================================================

Обновить состояние с помощью this.setState
Компонент может делать больше, чем просто читать свое собственное состояние. Компонент также может изменять свое собственное состояние.

Компонент изменяет свое состояние, вызывая функцию this.setState().

this.setState()принимает два аргумента: объект , который обновит состояние компонента, и обратный вызов. Вам вообще не нужен обратный вызов.

В редакторе кода взгляните на Example.js . Обратите внимание, что <Example />имеет состояние:

{
  mood:   'great',
  hungry: false
}
Теперь предположим, что это <Example />был вызов:

this.setState({ hungry: true });
После этого вызова <Example />состояние будет следующим:

{
  mood:   'great',
  hungry: true
}
moodЧасть государства остается неизменной!

this.setState()принимает объект и объединяет этот объект с текущим состоянием компонента. Если в текущем состоянии есть свойства, которые не являются частью этого объекта, то эти свойства остаются такими, какими они были.

=========================================================================

Наиболее распространенный способ вызова this.setState()является вызов пользовательской функции , которая оборачивает на this.setState()вызов. .makeSomeFog()это пример:

class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = { weather: 'sunny' };
    this.makeSomeFog = this.makeSomeFog.bind(this);
  }
 
  makeSomeFog() {
    this.setState({
      weather: 'foggy'
    });
  }
}

Обратите внимание, как метод makeSomeFog()содержит вызов this.setState().

Возможно, вы заметили там странную строчку:

this.makeSomeFog = this.makeSomeFog.bind(this);
Эта строка необходима, потому что makeSomeFog()тело содержит слово this. Поговорим об этом позже!

Давайте рассмотрим, как на this.setState()практике может работать обертка функций . В редакторе кода, прочитайте Mood.js весь путь до конца.

Вот как <Mood />можно установить состояние a :

Пользователь запускает событие (в данном случае событие щелчка, инициируемое щелчком по значку a <button></button>).

Событие из шага 1 прослушивается (в данном случае onClickатрибутом в строке 20).

Когда происходит это ожидаемое событие, оно вызывает функцию обработчика событий (в данном случае this.toggleMood(), вызываемую в строке 20 и определенную в строках 11-14).

Внутри корпуса обработчика событий , this.setState()называется (в данном случае на линию 13).

Компонент stateизменен!

Из-за того, как обработчики событий связаны в JavaScript, this.toggleMood()теряет свое значение thisпри использовании в строке 20. Следовательно, выражения this.state.moodи this.setStateв строках 12 и 13 не будут означать то, что они должны… если вы уже не связали правильный thisк this.toggleMood.

Вот почему мы должны выполнить привязку this.toggleMoodк thisстроке 8.

Для более подробного объяснения такого рода уловок связывания начните с документации React . Для менее любопытных, просто знайте, что в React всякий раз, когда вы определяете обработчик событий, который использует this, вам нужно добавить this.methodName = this.methodName.bind(this)в свой конструктор функцию.

Посмотрите на утверждение в строке 12. Для чего это нужно?

Строка 12 объявляет constnamed newMoodравным противоположности this.state.mood. Если this.state.mood«хорошо», то newMoodбудет «плохо», и наоборот.

В <Mood />экземпляре будет отображаться "Я чувствую себя хорошо!" вместе с кнопкой. Нажатие на кнопку изменит отображение на «Я чувствую себя плохо!» Повторное нажатие изменится на «Я чувствую себя хорошо!» И т. Д. Попробуйте выполнить пошаговое руководство в Mood.js и посмотрите, как все это работает.

И последнее замечание: вы не можете вызывать this.setState()изнутри функции рендеринга! Мы объясним почему в следующем упражнении.

================================================================

this.setState автоматически вызывает рендеринг
Во всем этом есть что-то странное.

Посмотрите еще раз на Toggle.js .

Когда пользователь нажимает на <button></button>, .changeColor()вызывается метод. Взгляните на .changeColor()определение пользователя.

.changeColor()звонки this.setState(), которые обновляются this.state.color. Однако, даже если this.state.colorвыполняется обновление с greenна yellow, одного этого недостаточно, чтобы изменить цвет экрана!

Цвет экрана не меняется до Toggle рендеринга.

Внутри функции рендеринга это строка:

<div style={{background:this.state.color}}>
который изменяет цвет виртуального объекта DOM на новый this.state.color, что в конечном итоге вызывает изменение экрана.

Если вы звоните .changeColor(), не должны вы тогда также должны позвонить .render()снова? .changeColor()только делает так, что при следующем рендеринге цвет будет другим. Почему вы сразу видите новый фон, если вы еще не отрендерили компонент?

Вот почему: каждый раз, когда вы вызываете this.setState (), this.setState () АВТОМАТИЧЕСКИ вызывает .render (), как только состояние изменяется.

Думайте о this.setState()двух вещах:, this.setState()сразу за которыми следует .render().

Вот почему нельзя вызывать this.setState()изнутри .render()метода! this.setState() автоматически звонит .render(). Если .render()вызывает this.setState(), то создается бесконечный цикл.